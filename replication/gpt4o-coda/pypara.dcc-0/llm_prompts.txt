

---- 2024-06-03 03:14:55.355679
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides day-count convention definitions and functionlity.\n\"\"\"\n\n__all__ = [\"DCC\", \"DCCRegistry\"]\n\nimport calendar\nimport datetime\nfrom decimal import Decimal\nfrom typing import Callable, Dict, Iterable, List, NamedTuple, Optional, Set, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom .commons.numbers import ONE, ZERO\nfrom .commons.zeitgeist import Date\nfrom .currencies import Currencies, Currency\nfrom .monetary import Money\n\n#: Defines a type alias for day count fraction calculation functions.\nDCFC = Callable[[Date, Date, Date, Optional[Decimal]], Decimal]\n\n\ndef _as_ccys(codes: Set[str]) -> Set[Currency]:\n    \"\"\"\n    Converts a set of currency codes to a set of currencies.\n    \"\"\"\n    return {Currencies[c] for c in codes}\n\n\ndef _get_date_range(start: Date, end: Date) -> Iterable[Date]:\n    \"\"\"\n    Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: A generator of dates.\n    \"\"\"\n    for i in range((end - start).days):\n        yield start + datetime.timedelta(days=i)\n\n\ndef _get_actual_day_count(start: Date, end: Date) -> int:\n    \"\"\"\n    Counts the actual number of days in the given period.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: The number of days in the given period.\n\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n    0\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n    1\n    \"\"\"\n    return (end - start).days\n\n\ndef _has_leap_day(start: Date, end: Date) -> bool:\n    \"\"\"\n    Indicates if the range has any leap day.\n    \"\"\"\n    ## Get all leap years:\n    years = {year for year in range(start.year, end.year + 1) if calendar.isleap(year)}\n\n    ## Check if any of the lap day falls in our range:\n    for year in years:\n        ## Construct the leap day:\n        leapday = datetime.date(year, 2, 29)\n\n        ## Is the leap date in the range?\n        if start <= leapday <= end:\n            ## Yes, the leap day is within the date range. Return True:\n            return True\n\n    ## No leap day in the range, return False:\n    return False\n\n\ndef _is_last_day_of_month(date: Date) -> bool:\n    \"\"\"\n    Indicates if the date is the last day of the month.\n    \"\"\"\n    return date.day == calendar.monthrange(date.year, date.month)[1]\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    ## Make sure that we have eom:\n    eom = eom or start.day\n\n    ## Get the starting month:\n    s_month = start.month\n\n    ## Get the period:\n    period = int(12 / frequency)\n\n    ## Get the current day, month and year:\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n\n    ## Get the payment schedule:\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period)])])\n\n    ## Filter out previous:\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n\n    ## Get the previous month and year:\n    p_year, p_month = (c_year, future[-1]) if future else (c_year - 1, schedule[-1])\n\n    ## Return the date:\n    if p_year < 1 or p_month < 1 or eom < 1:\n        return start\n\n    ## Construct and return the date safely:\n    return _construct_date(p_year, p_month, eom)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n# Unit test for method coupon of class DCC\ndef test_DCC_coupon():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:14:59.485178
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    ## Compute the ratio and return:\n    return p1 / p2 / Decimal(freq or ONE)\n\n\n@dcc(\n    \"Act/360\",\n    {\"Actual/360\", \"French\", \"360\"},\n    _as_ccys({\"AUD\", \"CAD\", \"CHF\", \"EUR\", \"USD\", \"DKK\", \"CZK\", \"HUF\", \"SEK\", \"IDR\", \"NOK\", \"JPY\", \"NZD\", \"THB\"}),\n)\ndef dcfc_act_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/360\" convention.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.17222222222222')\n    >>> round(dcfc_act_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17500000000000')\n    >>> round(dcfc_act_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.10000000000000')\n    >>> round(dcfc_act_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.34722222222222')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(360)\n\n\n@dcc(\"Act/365F\", {\"Actual/365 Fixed\", \"English\", \"365\"}, _as_ccys({\"GBP\", \"HKD\", \"INR\", \"PLN\", \"SGD\", \"ZAR\", \"MYR\"}))\ndef dcfc_act_365_f(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365F\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)\n\n\n@dcc(\"Act/365A\", {\"Actual/365 Actual\"})\ndef dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_isda\ndef test_dcfc_30_360_isda():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:15:04.118678
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func\n\n    return register_and_return_dcfc\n\n\n@dcc(\"Act/Act\", {\"Actual/Actual\", \"Actual/Actual (ISDA)\"})\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    ## Get all years of interest by checking the leap year:\n    years = {year: calendar.isleap(year) for year in range(start.year, asof.year + 1)}\n\n    ## Define the buffer of days for the day count. The former is for non-leap years, the latter for leap years:\n    buffer: List[int] = [0, 0]\n\n    ## Iterate over the date range and count:\n    for date in _get_date_range(start, asof):\n        ## Check the year and modify buffer accordingly:\n        if years[date.year]:\n            ## Yep, it is a leap year:\n            buffer[1] += 1\n        else:\n            ## Nope, not a leap year:\n            buffer[0] += 1\n\n    ## Done, compute and return:\n    return Decimal(buffer[0]) / Decimal(365) + Decimal(buffer[1]) / Decimal(366)\n\n\n@dcc(\"Act/Act (ICMA)\", {\"Actual/Actual (ICMA)\", \"ISMA-99\", \"Act/Act (ISMA)\"})\ndef dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    ## Get the number of actual days:\n    p1 = Decimal(_get_actual_day_count(start, asof))\n\n    ## Get the number of days in the period:\n    p2 = Decimal(_get_actual_day_count(start, end))\n\n    ## Compute the ratio and return:\n    return p1 / p2 / Decimal(freq or ONE)\n\n\n@dcc(\n    \"Act/360\",\n    {\"Actual/360\", \"French\", \"360\"},\n    _as_ccys({\"AUD\", \"CAD\", \"CHF\", \"EUR\", \"USD\", \"DKK\", \"CZK\", \"HUF\", \"SEK\", \"IDR\", \"NOK\", \"JPY\", \"NZD\", \"THB\"}),\n)\ndef dcfc_act_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/360\" convention.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.17222222222222')\n    >>> round(dcfc_act_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17500000000000')\n    >>> round(dcfc_act_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.10000000000000')\n    >>> round(dcfc_act_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.34722222222222')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(360)\n\n\n@dcc(\"Act/365F\", {\"Actual/365 Fixed\", \"English\", \"365\"}, _as_ccys({\"GBP\", \"HKD\", \"INR\", \"PLN\", \"SGD\", \"ZAR\", \"MYR\"}))\ndef dcfc_act_365_f(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365F\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)\n\n\n@dcc(\"Act/365A\", {\"Actual/365 Actual\"})\ndef dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n# Unit test for function dcfc_act_365_l\ndef test_dcfc_act_365_l():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:15:08.341981
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n\n\nclass DCCRegistryMachinery:\n    \"\"\"\n    Provides the day count registry model.\n\n    >>> principal = Money.of(Currencies[\"USD\"], Decimal(1000000), datetime.date.today())\n    >>> start = datetime.date(2007, 12, 28)\n    >>> end = datetime.date(2008, 2, 28)\n    >>> rate = Decimal(0.01)\n    >>> dcc = DCCRegistry.find(\"Act/Act\")\n    >>> round(dcc.calculate_fraction(start, end, end), 14)\n    Decimal('0.16942884946478')\n    >>> dcc.interest(principal, rate, start, end, end).qty\n    Decimal('1694.29')\n    >>> dcc.interest(principal, rate, end, start, start).qty\n    Decimal('0.00')\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        Initializes the registry.\n        \"\"\"\n        ## Define the main registry buffer:\n        self._buffer_main: Dict[str, DCC] = {}\n\n        ## Defines the registry buffer for alternative DCC names:\n        self._buffer_altn: Dict[str, DCC] = {}\n\n    def _is_registered(self, name: str) -> bool:\n        \"\"\"\n        Checks if the given name is ever registered before.\n        \"\"\"\n        return name in self._buffer_main or name in self._buffer_altn\n\n    def register(self, dcc: DCC) -> None:\n        \"\"\"\n        Attempts to register the given day count convention.\n        \"\"\"\n        ## Check if the main name is ever registered before:\n        if self._is_registered(dcc.name):\n            ## Yep, raise a TypeError:\n            raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n        ## Add to the main buffer:\n        self._buffer_main[dcc.name] = dcc\n\n        ## Check if there is any registry conflict:\n        for name in dcc.altnames:\n            ## Check if the name is ever registered:\n            if self._is_registered(name):\n                ## Yep, raise a TypeError:\n                raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n            ## Register to the alternative buffer:\n            self._buffer_altn[name] = dcc\n\n    def _find_strict(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n        \"\"\"\n        return self._buffer_main.get(name) or self._buffer_altn.get(name)\n\n    def find(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n\n        Note that all day count conventions are registered under stripped, uppercased names. Therefore,\n        the implementation will first attempt to find by given name as is. If it can not find it, it will\n        strip and uppercase the name and try to find it as such as a last resort.\n        \"\"\"\n        return self._find_strict(name) or self._find_strict(name.strip().upper())\n\n    @property\n    def registry(self) -> List[DCC]:\n        \"\"\"\n        Returns the main registry values.\n        \"\"\"\n        return list(self._buffer_main.values())\n\n    @property\n    def table(self) -> Dict[str, DCC]:\n        \"\"\"\n        Returns a lookup table for available day count conventions.\n        \"\"\"\n        return {**{k: v for k, v in self._buffer_main.items()}, **{k: v for k, v in self._buffer_altn.items()}}\n\n\n#: Defines the default DCC registry.\nDCCRegistry = DCCRegistryMachinery()\n\n\ndef dcc(name: str, altnames: Optional[Set[str]] = None, ccys: Optional[Set[Currency]] = None) -> Callable[[DCFC], DCFC]:\n    \"\"\"\n    Registers a day count fraction calculator under the given names and alternative names (if any).\n\n    :param name: The name of the day count convention.\n    :param altnames: A set of alternative names of the day count convention, if any.\n    :param ccys: A set of currencies which are known to use this convention by default, if any.\n    :return: Registered day count fraction calculation function.\n    \"\"\"\n\n    def register_and_return_dcfc(func: DCFC) -> DCFC:\n        \"\"\"\n        Registers the given day count fraction calculator and returns it.\n\n        :param func: Day count fraction calculation function to be registered.\n        :return: Registered day count fraction calculation function.\n        \"\"\"\n        ## Create the DCC instance:\n        dcc = DCC(name, altnames or set([]), ccys or set([]), func)\n\n        ## Attempt to register the DCC:\n        DCCRegistry.register(dcc)\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func\n\n    return register_and_return_dcfc\n\n\n@dcc(\"Act/Act\", {\"Actual/Actual\", \"Actual/Actual (ISDA)\"})\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    ## Get all years of interest by checking the leap year:\n    years = {year: calendar.isleap(year) for year in range(start.year, asof.year + 1)}\n\n    ## Define the buffer of days for the day count. The former is for non-leap years, the latter for leap years:\n    buffer: List[int] = [0, 0]\n\n    ## Iterate over the date range and count:\n    for date in _get_date_range(start, asof):\n        ## Check the year and modify buffer accordingly:\n        if years[date.year]:\n            ## Yep, it is a leap year:\n            buffer[1] += 1\n        else:\n            ## Nope, not a leap year:\n            buffer[0] += 1\n\n    ## Done, compute and return:\n    return Decimal(buffer[0]) / Decimal(365) + Decimal(buffer[1]) / Decimal(366)\n# Unit test for function dcfc_act_act\ndef test_dcfc_act_act():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:15:11.580823
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides day-count convention definitions and functionlity.\n\"\"\"\n\n__all__ = [\"DCC\", \"DCCRegistry\"]\n\nimport calendar\nimport datetime\nfrom decimal import Decimal\nfrom typing import Callable, Dict, Iterable, List, NamedTuple, Optional, Set, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom .commons.numbers import ONE, ZERO\nfrom .commons.zeitgeist import Date\nfrom .currencies import Currencies, Currency\nfrom .monetary import Money\n\n#: Defines a type alias for day count fraction calculation functions.\nDCFC = Callable[[Date, Date, Date, Optional[Decimal]], Decimal]\n\n\ndef _as_ccys(codes: Set[str]) -> Set[Currency]:\n    \"\"\"\n    Converts a set of currency codes to a set of currencies.\n    \"\"\"\n    return {Currencies[c] for c in codes}\n\n\ndef _get_date_range(start: Date, end: Date) -> Iterable[Date]:\n    \"\"\"\n    Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: A generator of dates.\n    \"\"\"\n    for i in range((end - start).days):\n        yield start + datetime.timedelta(days=i)\n\n\ndef _get_actual_day_count(start: Date, end: Date) -> int:\n    \"\"\"\n    Counts the actual number of days in the given period.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: The number of days in the given period.\n\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n    0\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n    1\n    \"\"\"\n    return (end - start).days\n\n\ndef _has_leap_day(start: Date, end: Date) -> bool:\n    \"\"\"\n    Indicates if the range has any leap day.\n    \"\"\"\n    ## Get all leap years:\n    years = {year for year in range(start.year, end.year + 1) if calendar.isleap(year)}\n\n    ## Check if any of the lap day falls in our range:\n    for year in years:\n        ## Construct the leap day:\n        leapday = datetime.date(year, 2, 29)\n\n        ## Is the leap date in the range?\n        if start <= leapday <= end:\n            ## Yes, the leap day is within the date range. Return True:\n            return True\n\n    ## No leap day in the range, return False:\n    return False\n\n\ndef _is_last_day_of_month(date: Date) -> bool:\n    \"\"\"\n    Indicates if the date is the last day of the month.\n    \"\"\"\n    return date.day == calendar.monthrange(date.year, date.month)[1]\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    ## Make sure that we have eom:\n    eom = eom or start.day\n\n    ## Get the starting month:\n    s_month = start.month\n\n    ## Get the period:\n    period = int(12 / frequency)\n\n    ## Get the current day, month and year:\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n\n    ## Get the payment schedule:\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period)])])\n\n    ## Filter out previous:\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n\n    ## Get the previous month and year:\n    p_year, p_month = (c_year, future[-1]) if future else (c_year - 1, schedule[-1])\n\n    ## Return the date:\n    if p_year < 1 or p_month < 1 or eom < 1:\n        return start\n\n    ## Construct and return the date safely:\n    return _construct_date(p_year, p_month, eom)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n# Unit test for method calculate_daily_fraction of class DCC\ndef test_DCC_calculate_daily_fraction():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:15:15.356492
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_e_plus_360\ndef test_dcfc_30_e_plus_360():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:15:18.902627
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)\n\n\n@dcc(\"Act/365A\", {\"Actual/365 Actual\"})\ndef dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_e_360\ndef test_dcfc_30_e_360():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:15:22.218667
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 German\", {\"30E/360 ISDA\"})\ndef dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    ## Get the new asof date, if required:\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 US\", {\"30U/360\", \"30US/360\"})\ndef dcfc_30_360_us(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get D1 and D2:\n    d1 = start.day\n    d2 = asof.day\n\n    ## Need to change D1?\n    if _is_last_day_of_month(start):\n        ## Yep, change it:\n        d1 = 30\n\n        ## Shall we change the d2, too?\n        if _is_last_day_of_month(asof):\n            d2 = 30\n\n    ## Revisit d2:\n    if d2 == 31 and (d1 == 30 or d1 == 31):\n        d2 = 30\n\n    ## Revisit d1:\n    if d1 == 31:\n        d1 = 30\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, return:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_us\ndef test_dcfc_30_360_us():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:15:27.696857
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides day-count convention definitions and functionlity.\n\"\"\"\n\n__all__ = [\"DCC\", \"DCCRegistry\"]\n\nimport calendar\nimport datetime\nfrom decimal import Decimal\nfrom typing import Callable, Dict, Iterable, List, NamedTuple, Optional, Set, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom .commons.numbers import ONE, ZERO\nfrom .commons.zeitgeist import Date\nfrom .currencies import Currencies, Currency\nfrom .monetary import Money\n\n#: Defines a type alias for day count fraction calculation functions.\nDCFC = Callable[[Date, Date, Date, Optional[Decimal]], Decimal]\n\n\ndef _as_ccys(codes: Set[str]) -> Set[Currency]:\n    \"\"\"\n    Converts a set of currency codes to a set of currencies.\n    \"\"\"\n    return {Currencies[c] for c in codes}\n\n\ndef _get_date_range(start: Date, end: Date) -> Iterable[Date]:\n    \"\"\"\n    Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: A generator of dates.\n    \"\"\"\n    for i in range((end - start).days):\n        yield start + datetime.timedelta(days=i)\n\n\ndef _get_actual_day_count(start: Date, end: Date) -> int:\n    \"\"\"\n    Counts the actual number of days in the given period.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: The number of days in the given period.\n\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n    0\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n    1\n    \"\"\"\n    return (end - start).days\n\n\ndef _has_leap_day(start: Date, end: Date) -> bool:\n    \"\"\"\n    Indicates if the range has any leap day.\n    \"\"\"\n    ## Get all leap years:\n    years = {year for year in range(start.year, end.year + 1) if calendar.isleap(year)}\n\n    ## Check if any of the lap day falls in our range:\n    for year in years:\n        ## Construct the leap day:\n        leapday = datetime.date(year, 2, 29)\n\n        ## Is the leap date in the range?\n        if start <= leapday <= end:\n            ## Yes, the leap day is within the date range. Return True:\n            return True\n\n    ## No leap day in the range, return False:\n    return False\n\n\ndef _is_last_day_of_month(date: Date) -> bool:\n    \"\"\"\n    Indicates if the date is the last day of the month.\n    \"\"\"\n    return date.day == calendar.monthrange(date.year, date.month)[1]\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    ## Make sure that we have eom:\n    eom = eom or start.day\n\n    ## Get the starting month:\n    s_month = start.month\n\n    ## Get the period:\n    period = int(12 / frequency)\n\n    ## Get the current day, month and year:\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n\n    ## Get the payment schedule:\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period)])])\n\n    ## Filter out previous:\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n\n    ## Get the previous month and year:\n    p_year, p_month = (c_year, future[-1]) if future else (c_year - 1, schedule[-1])\n\n    ## Return the date:\n    if p_year < 1 or p_month < 1 or eom < 1:\n        return start\n\n    ## Construct and return the date safely:\n    return _construct_date(p_year, p_month, eom)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n# Unit test for method calculate_fraction of class DCC\ndef test_DCC_calculate_fraction():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:15:30.854561
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 German\", {\"30E/360 ISDA\"})\ndef dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    ## Get the new asof date, if required:\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 US\", {\"30U/360\", \"30US/360\"})\ndef dcfc_30_360_us(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get D1 and D2:\n    d1 = start.day\n    d2 = asof.day\n\n    ## Need to change D1?\n    if _is_last_day_of_month(start):\n        ## Yep, change it:\n        d1 = 30\n\n        ## Shall we change the d2, too?\n        if _is_last_day_of_month(asof):\n            d2 = 30\n\n    ## Revisit d2:\n    if d2 == 31 and (d1 == 30 or d1 == 31):\n        d2 = 30\n\n    ## Revisit d1:\n    if d1 == 31:\n        d1 = 30\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, return:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_us\ndef test_dcfc_30_360_us():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:16:28.458401
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    ## Compute the ratio and return:\n    return p1 / p2 / Decimal(freq or ONE)\n\n\n@dcc(\n    \"Act/360\",\n    {\"Actual/360\", \"French\", \"360\"},\n    _as_ccys({\"AUD\", \"CAD\", \"CHF\", \"EUR\", \"USD\", \"DKK\", \"CZK\", \"HUF\", \"SEK\", \"IDR\", \"NOK\", \"JPY\", \"NZD\", \"THB\"}),\n)\ndef dcfc_act_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/360\" convention.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.17222222222222')\n    >>> round(dcfc_act_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17500000000000')\n    >>> round(dcfc_act_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.10000000000000')\n    >>> round(dcfc_act_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.34722222222222')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(360)\n\n\n@dcc(\"Act/365F\", {\"Actual/365 Fixed\", \"English\", \"365\"}, _as_ccys({\"GBP\", \"HKD\", \"INR\", \"PLN\", \"SGD\", \"ZAR\", \"MYR\"}))\ndef dcfc_act_365_f(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365F\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)\n\n\n@dcc(\"Act/365A\", {\"Actual/365 Actual\"})\ndef dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_isda\ndef test_dcfc_30_360_isda():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:16:31.765171
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    ## Compute the ratio and return:\n    return p1 / p2 / Decimal(freq or ONE)\n\n\n@dcc(\n    \"Act/360\",\n    {\"Actual/360\", \"French\", \"360\"},\n    _as_ccys({\"AUD\", \"CAD\", \"CHF\", \"EUR\", \"USD\", \"DKK\", \"CZK\", \"HUF\", \"SEK\", \"IDR\", \"NOK\", \"JPY\", \"NZD\", \"THB\"}),\n)\ndef dcfc_act_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/360\" convention.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.17222222222222')\n    >>> round(dcfc_act_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17500000000000')\n    >>> round(dcfc_act_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.10000000000000')\n    >>> round(dcfc_act_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.34722222222222')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(360)\n\n\n@dcc(\"Act/365F\", {\"Actual/365 Fixed\", \"English\", \"365\"}, _as_ccys({\"GBP\", \"HKD\", \"INR\", \"PLN\", \"SGD\", \"ZAR\", \"MYR\"}))\ndef dcfc_act_365_f(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365F\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)\n\n\n@dcc(\"Act/365A\", {\"Actual/365 Actual\"})\ndef dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_isda\ndef test_dcfc_30_360_isda():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:16:36.055223
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    ## Compute the ratio and return:\n    return p1 / p2 / Decimal(freq or ONE)\n\n\n@dcc(\n    \"Act/360\",\n    {\"Actual/360\", \"French\", \"360\"},\n    _as_ccys({\"AUD\", \"CAD\", \"CHF\", \"EUR\", \"USD\", \"DKK\", \"CZK\", \"HUF\", \"SEK\", \"IDR\", \"NOK\", \"JPY\", \"NZD\", \"THB\"}),\n)\ndef dcfc_act_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/360\" convention.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.17222222222222')\n    >>> round(dcfc_act_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17500000000000')\n    >>> round(dcfc_act_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.10000000000000')\n    >>> round(dcfc_act_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.34722222222222')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(360)\n\n\n@dcc(\"Act/365F\", {\"Actual/365 Fixed\", \"English\", \"365\"}, _as_ccys({\"GBP\", \"HKD\", \"INR\", \"PLN\", \"SGD\", \"ZAR\", \"MYR\"}))\ndef dcfc_act_365_f(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365F\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)\n\n\n@dcc(\"Act/365A\", {\"Actual/365 Actual\"})\ndef dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_isda\ndef test_dcfc_30_360_isda():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:16:39.893106
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides day-count convention definitions and functionlity.\n\"\"\"\n\n__all__ = [\"DCC\", \"DCCRegistry\"]\n\nimport calendar\nimport datetime\nfrom decimal import Decimal\nfrom typing import Callable, Dict, Iterable, List, NamedTuple, Optional, Set, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom .commons.numbers import ONE, ZERO\nfrom .commons.zeitgeist import Date\nfrom .currencies import Currencies, Currency\nfrom .monetary import Money\n\n#: Defines a type alias for day count fraction calculation functions.\nDCFC = Callable[[Date, Date, Date, Optional[Decimal]], Decimal]\n\n\ndef _as_ccys(codes: Set[str]) -> Set[Currency]:\n    \"\"\"\n    Converts a set of currency codes to a set of currencies.\n    \"\"\"\n    return {Currencies[c] for c in codes}\n\n\ndef _get_date_range(start: Date, end: Date) -> Iterable[Date]:\n    \"\"\"\n    Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: A generator of dates.\n    \"\"\"\n    for i in range((end - start).days):\n        yield start + datetime.timedelta(days=i)\n\n\ndef _get_actual_day_count(start: Date, end: Date) -> int:\n    \"\"\"\n    Counts the actual number of days in the given period.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: The number of days in the given period.\n\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n    0\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n    1\n    \"\"\"\n    return (end - start).days\n\n\ndef _has_leap_day(start: Date, end: Date) -> bool:\n    \"\"\"\n    Indicates if the range has any leap day.\n    \"\"\"\n    ## Get all leap years:\n    years = {year for year in range(start.year, end.year + 1) if calendar.isleap(year)}\n\n    ## Check if any of the lap day falls in our range:\n    for year in years:\n        ## Construct the leap day:\n        leapday = datetime.date(year, 2, 29)\n\n        ## Is the leap date in the range?\n        if start <= leapday <= end:\n            ## Yes, the leap day is within the date range. Return True:\n            return True\n\n    ## No leap day in the range, return False:\n    return False\n\n\ndef _is_last_day_of_month(date: Date) -> bool:\n    \"\"\"\n    Indicates if the date is the last day of the month.\n    \"\"\"\n    return date.day == calendar.monthrange(date.year, date.month)[1]\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    ## Make sure that we have eom:\n    eom = eom or start.day\n\n    ## Get the starting month:\n    s_month = start.month\n\n    ## Get the period:\n    period = int(12 / frequency)\n\n    ## Get the current day, month and year:\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n\n    ## Get the payment schedule:\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period)])])\n\n    ## Filter out previous:\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n\n    ## Get the previous month and year:\n    p_year, p_month = (c_year, future[-1]) if future else (c_year - 1, schedule[-1])\n\n    ## Return the date:\n    if p_year < 1 or p_month < 1 or eom < 1:\n        return start\n\n    ## Construct and return the date safely:\n    return _construct_date(p_year, p_month, eom)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n# Unit test for method calculate_daily_fraction of class DCC\ndef test_DCC_calculate_daily_fraction():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:16:43.309582
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n\n\nclass DCCRegistryMachinery:\n    \"\"\"\n    Provides the day count registry model.\n\n    >>> principal = Money.of(Currencies[\"USD\"], Decimal(1000000), datetime.date.today())\n    >>> start = datetime.date(2007, 12, 28)\n    >>> end = datetime.date(2008, 2, 28)\n    >>> rate = Decimal(0.01)\n    >>> dcc = DCCRegistry.find(\"Act/Act\")\n    >>> round(dcc.calculate_fraction(start, end, end), 14)\n    Decimal('0.16942884946478')\n    >>> dcc.interest(principal, rate, start, end, end).qty\n    Decimal('1694.29')\n    >>> dcc.interest(principal, rate, end, start, start).qty\n    Decimal('0.00')\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        Initializes the registry.\n        \"\"\"\n        ## Define the main registry buffer:\n        self._buffer_main: Dict[str, DCC] = {}\n\n        ## Defines the registry buffer for alternative DCC names:\n        self._buffer_altn: Dict[str, DCC] = {}\n\n    def _is_registered(self, name: str) -> bool:\n        \"\"\"\n        Checks if the given name is ever registered before.\n        \"\"\"\n        return name in self._buffer_main or name in self._buffer_altn\n\n    def register(self, dcc: DCC) -> None:\n        \"\"\"\n        Attempts to register the given day count convention.\n        \"\"\"\n        ## Check if the main name is ever registered before:\n        if self._is_registered(dcc.name):\n            ## Yep, raise a TypeError:\n            raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n        ## Add to the main buffer:\n        self._buffer_main[dcc.name] = dcc\n\n        ## Check if there is any registry conflict:\n        for name in dcc.altnames:\n            ## Check if the name is ever registered:\n            if self._is_registered(name):\n                ## Yep, raise a TypeError:\n                raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n            ## Register to the alternative buffer:\n            self._buffer_altn[name] = dcc\n\n    def _find_strict(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n        \"\"\"\n        return self._buffer_main.get(name) or self._buffer_altn.get(name)\n\n    def find(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n\n        Note that all day count conventions are registered under stripped, uppercased names. Therefore,\n        the implementation will first attempt to find by given name as is. If it can not find it, it will\n        strip and uppercase the name and try to find it as such as a last resort.\n        \"\"\"\n        return self._find_strict(name) or self._find_strict(name.strip().upper())\n\n    @property\n    def registry(self) -> List[DCC]:\n        \"\"\"\n        Returns the main registry values.\n        \"\"\"\n        return list(self._buffer_main.values())\n\n    @property\n    def table(self) -> Dict[str, DCC]:\n        \"\"\"\n        Returns a lookup table for available day count conventions.\n        \"\"\"\n        return {**{k: v for k, v in self._buffer_main.items()}, **{k: v for k, v in self._buffer_altn.items()}}\n\n\n#: Defines the default DCC registry.\nDCCRegistry = DCCRegistryMachinery()\n\n\ndef dcc(name: str, altnames: Optional[Set[str]] = None, ccys: Optional[Set[Currency]] = None) -> Callable[[DCFC], DCFC]:\n    \"\"\"\n    Registers a day count fraction calculator under the given names and alternative names (if any).\n\n    :param name: The name of the day count convention.\n    :param altnames: A set of alternative names of the day count convention, if any.\n    :param ccys: A set of currencies which are known to use this convention by default, if any.\n    :return: Registered day count fraction calculation function.\n    \"\"\"\n\n    def register_and_return_dcfc(func: DCFC) -> DCFC:\n        \"\"\"\n        Registers the given day count fraction calculator and returns it.\n\n        :param func: Day count fraction calculation function to be registered.\n        :return: Registered day count fraction calculation function.\n        \"\"\"\n        ## Create the DCC instance:\n        dcc = DCC(name, altnames or set([]), ccys or set([]), func)\n\n        ## Attempt to register the DCC:\n        DCCRegistry.register(dcc)\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func\n\n    return register_and_return_dcfc\n\n\n@dcc(\"Act/Act\", {\"Actual/Actual\", \"Actual/Actual (ISDA)\"})\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    ## Get all years of interest by checking the leap year:\n    years = {year: calendar.isleap(year) for year in range(start.year, asof.year + 1)}\n\n    ## Define the buffer of days for the day count. The former is for non-leap years, the latter for leap years:\n    buffer: List[int] = [0, 0]\n\n    ## Iterate over the date range and count:\n    for date in _get_date_range(start, asof):\n        ## Check the year and modify buffer accordingly:\n        if years[date.year]:\n            ## Yep, it is a leap year:\n            buffer[1] += 1\n        else:\n            ## Nope, not a leap year:\n            buffer[0] += 1\n\n    ## Done, compute and return:\n    return Decimal(buffer[0]) / Decimal(365) + Decimal(buffer[1]) / Decimal(366)\n\n\n@dcc(\"Act/Act (ICMA)\", {\"Actual/Actual (ICMA)\", \"ISMA-99\", \"Act/Act (ISMA)\"})\ndef dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    ## Get the number of actual days:\n    p1 = Decimal(_get_actual_day_count(start, asof))\n\n    ## Get the number of days in the period:\n    p2 = Decimal(_get_actual_day_count(start, end))\n\n    ## Compute the ratio and return:\n    return p1 / p2 / Decimal(freq or ONE)\n# Unit test for function dcfc_act_act_icma\ndef test_dcfc_act_act_icma():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:16:45.279139
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides day-count convention definitions and functionlity.\n\"\"\"\n\n__all__ = [\"DCC\", \"DCCRegistry\"]\n\nimport calendar\nimport datetime\nfrom decimal import Decimal\nfrom typing import Callable, Dict, Iterable, List, NamedTuple, Optional, Set, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom .commons.numbers import ONE, ZERO\nfrom .commons.zeitgeist import Date\nfrom .currencies import Currencies, Currency\nfrom .monetary import Money\n\n#: Defines a type alias for day count fraction calculation functions.\nDCFC = Callable[[Date, Date, Date, Optional[Decimal]], Decimal]\n\n\ndef _as_ccys(codes: Set[str]) -> Set[Currency]:\n    \"\"\"\n    Converts a set of currency codes to a set of currencies.\n    \"\"\"\n    return {Currencies[c] for c in codes}\n\n\ndef _get_date_range(start: Date, end: Date) -> Iterable[Date]:\n    \"\"\"\n    Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: A generator of dates.\n    \"\"\"\n    for i in range((end - start).days):\n        yield start + datetime.timedelta(days=i)\n\n\ndef _get_actual_day_count(start: Date, end: Date) -> int:\n    \"\"\"\n    Counts the actual number of days in the given period.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: The number of days in the given period.\n\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n    0\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n    1\n    \"\"\"\n    return (end - start).days\n\n\ndef _has_leap_day(start: Date, end: Date) -> bool:\n    \"\"\"\n    Indicates if the range has any leap day.\n    \"\"\"\n    ## Get all leap years:\n    years = {year for year in range(start.year, end.year + 1) if calendar.isleap(year)}\n\n    ## Check if any of the lap day falls in our range:\n    for year in years:\n        ## Construct the leap day:\n        leapday = datetime.date(year, 2, 29)\n\n        ## Is the leap date in the range?\n        if start <= leapday <= end:\n            ## Yes, the leap day is within the date range. Return True:\n            return True\n\n    ## No leap day in the range, return False:\n    return False\n\n\ndef _is_last_day_of_month(date: Date) -> bool:\n    \"\"\"\n    Indicates if the date is the last day of the month.\n    \"\"\"\n    return date.day == calendar.monthrange(date.year, date.month)[1]\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    ## Make sure that we have eom:\n    eom = eom or start.day\n\n    ## Get the starting month:\n    s_month = start.month\n\n    ## Get the period:\n    period = int(12 / frequency)\n\n    ## Get the current day, month and year:\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n\n    ## Get the payment schedule:\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period)])])\n\n    ## Filter out previous:\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n\n    ## Get the previous month and year:\n    p_year, p_month = (c_year, future[-1]) if future else (c_year - 1, schedule[-1])\n\n    ## Return the date:\n    if p_year < 1 or p_month < 1 or eom < 1:\n        return start\n\n    ## Construct and return the date safely:\n    return _construct_date(p_year, p_month, eom)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n# Unit test for method interest of class DCC\ndef test_DCC_interest():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:16:49.103378
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)\n\n\n@dcc(\"Act/365A\", {\"Actual/365 Actual\"})\ndef dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_e_360\ndef test_dcfc_30_e_360():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:16:52.367643
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_e_plus_360\ndef test_dcfc_30_e_plus_360():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:16:56.340694
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides day-count convention definitions and functionlity.\n\"\"\"\n\n__all__ = [\"DCC\", \"DCCRegistry\"]\n\nimport calendar\nimport datetime\nfrom decimal import Decimal\nfrom typing import Callable, Dict, Iterable, List, NamedTuple, Optional, Set, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom .commons.numbers import ONE, ZERO\nfrom .commons.zeitgeist import Date\nfrom .currencies import Currencies, Currency\nfrom .monetary import Money\n\n#: Defines a type alias for day count fraction calculation functions.\nDCFC = Callable[[Date, Date, Date, Optional[Decimal]], Decimal]\n\n\ndef _as_ccys(codes: Set[str]) -> Set[Currency]:\n    \"\"\"\n    Converts a set of currency codes to a set of currencies.\n    \"\"\"\n    return {Currencies[c] for c in codes}\n\n\ndef _get_date_range(start: Date, end: Date) -> Iterable[Date]:\n    \"\"\"\n    Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: A generator of dates.\n    \"\"\"\n    for i in range((end - start).days):\n        yield start + datetime.timedelta(days=i)\n\n\ndef _get_actual_day_count(start: Date, end: Date) -> int:\n    \"\"\"\n    Counts the actual number of days in the given period.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: The number of days in the given period.\n\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n    0\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n    1\n    \"\"\"\n    return (end - start).days\n\n\ndef _has_leap_day(start: Date, end: Date) -> bool:\n    \"\"\"\n    Indicates if the range has any leap day.\n    \"\"\"\n    ## Get all leap years:\n    years = {year for year in range(start.year, end.year + 1) if calendar.isleap(year)}\n\n    ## Check if any of the lap day falls in our range:\n    for year in years:\n        ## Construct the leap day:\n        leapday = datetime.date(year, 2, 29)\n\n        ## Is the leap date in the range?\n        if start <= leapday <= end:\n            ## Yes, the leap day is within the date range. Return True:\n            return True\n\n    ## No leap day in the range, return False:\n    return False\n\n\ndef _is_last_day_of_month(date: Date) -> bool:\n    \"\"\"\n    Indicates if the date is the last day of the month.\n    \"\"\"\n    return date.day == calendar.monthrange(date.year, date.month)[1]\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    ## Make sure that we have eom:\n    eom = eom or start.day\n\n    ## Get the starting month:\n    s_month = start.month\n\n    ## Get the period:\n    period = int(12 / frequency)\n\n    ## Get the current day, month and year:\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n\n    ## Get the payment schedule:\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period)])])\n\n    ## Filter out previous:\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n\n    ## Get the previous month and year:\n    p_year, p_month = (c_year, future[-1]) if future else (c_year - 1, schedule[-1])\n\n    ## Return the date:\n    if p_year < 1 or p_month < 1 or eom < 1:\n        return start\n\n    ## Construct and return the date safely:\n    return _construct_date(p_year, p_month, eom)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n# Unit test for method calculate_fraction of class DCC\ndef test_DCC_calculate_fraction():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:16:59.869862
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 German\", {\"30E/360 ISDA\"})\ndef dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    ## Get the new asof date, if required:\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 US\", {\"30U/360\", \"30US/360\"})\ndef dcfc_30_360_us(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get D1 and D2:\n    d1 = start.day\n    d2 = asof.day\n\n    ## Need to change D1?\n    if _is_last_day_of_month(start):\n        ## Yep, change it:\n        d1 = 30\n\n        ## Shall we change the d2, too?\n        if _is_last_day_of_month(asof):\n            d2 = 30\n\n    ## Revisit d2:\n    if d2 == 31 and (d1 == 30 or d1 == 31):\n        d2 = 30\n\n    ## Revisit d1:\n    if d1 == 31:\n        d1 = 30\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, return:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_us\ndef test_dcfc_30_360_us():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:18:53.810249
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)\n\n\n@dcc(\"Act/365A\", {\"Actual/365 Actual\"})\ndef dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_e_360\ndef test_dcfc_30_e_360():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:18:57.090449
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 German\", {\"30E/360 ISDA\"})\ndef dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    ## Get the new asof date, if required:\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_german\ndef test_dcfc_30_360_german():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:19:00.462896
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n        \"\"\"\n        return self._find_strict(name) or self._find_strict(name.strip().upper())\n\n    @property\n    def registry(self) -> List[DCC]:\n        \"\"\"\n        Returns the main registry values.\n        \"\"\"\n        return list(self._buffer_main.values())\n\n    @property\n    def table(self) -> Dict[str, DCC]:\n        \"\"\"\n        Returns a lookup table for available day count conventions.\n        \"\"\"\n        return {**{k: v for k, v in self._buffer_main.items()}, **{k: v for k, v in self._buffer_altn.items()}}\n\n\n#: Defines the default DCC registry.\nDCCRegistry = DCCRegistryMachinery()\n\n\ndef dcc(name: str, altnames: Optional[Set[str]] = None, ccys: Optional[Set[Currency]] = None) -> Callable[[DCFC], DCFC]:\n    \"\"\"\n    Registers a day count fraction calculator under the given names and alternative names (if any).\n\n    :param name: The name of the day count convention.\n    :param altnames: A set of alternative names of the day count convention, if any.\n    :param ccys: A set of currencies which are known to use this convention by default, if any.\n    :return: Registered day count fraction calculation function.\n    \"\"\"\n\n    def register_and_return_dcfc(func: DCFC) -> DCFC:\n        \"\"\"\n        Registers the given day count fraction calculator and returns it.\n\n        :param func: Day count fraction calculation function to be registered.\n        :return: Registered day count fraction calculation function.\n        \"\"\"\n        ## Create the DCC instance:\n        dcc = DCC(name, altnames or set([]), ccys or set([]), func)\n\n        ## Attempt to register the DCC:\n        DCCRegistry.register(dcc)\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func\n\n    return register_and_return_dcfc\n\n\n@dcc(\"Act/Act\", {\"Actual/Actual\", \"Actual/Actual (ISDA)\"})\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    ## Get all years of interest by checking the leap year:\n    years = {year: calendar.isleap(year) for year in range(start.year, asof.year + 1)}\n\n    ## Define the buffer of days for the day count. The former is for non-leap years, the latter for leap years:\n    buffer: List[int] = [0, 0]\n\n    ## Iterate over the date range and count:\n    for date in _get_date_range(start, asof):\n        ## Check the year and modify buffer accordingly:\n        if years[date.year]:\n            ## Yep, it is a leap year:\n            buffer[1] += 1\n        else:\n            ## Nope, not a leap year:\n            buffer[0] += 1\n\n    ## Done, compute and return:\n    return Decimal(buffer[0]) / Decimal(365) + Decimal(buffer[1]) / Decimal(366)\n\n\n@dcc(\"Act/Act (ICMA)\", {\"Actual/Actual (ICMA)\", \"ISMA-99\", \"Act/Act (ISMA)\"})\ndef dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    ## Get the number of actual days:\n    p1 = Decimal(_get_actual_day_count(start, asof))\n\n    ## Get the number of days in the period:\n    p2 = Decimal(_get_actual_day_count(start, end))\n\n    ## Compute the ratio and return:\n    return p1 / p2 / Decimal(freq or ONE)\n\n\n@dcc(\n    \"Act/360\",\n    {\"Actual/360\", \"French\", \"360\"},\n    _as_ccys({\"AUD\", \"CAD\", \"CHF\", \"EUR\", \"USD\", \"DKK\", \"CZK\", \"HUF\", \"SEK\", \"IDR\", \"NOK\", \"JPY\", \"NZD\", \"THB\"}),\n)\ndef dcfc_act_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/360\" convention.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.17222222222222')\n    >>> round(dcfc_act_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17500000000000')\n    >>> round(dcfc_act_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.10000000000000')\n    >>> round(dcfc_act_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.34722222222222')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(360)\n\n\n@dcc(\"Act/365F\", {\"Actual/365 Fixed\", \"English\", \"365\"}, _as_ccys({\"GBP\", \"HKD\", \"INR\", \"PLN\", \"SGD\", \"ZAR\", \"MYR\"}))\ndef dcfc_act_365_f(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365F\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)\n\n\n@dcc(\"Act/365A\", {\"Actual/365 Actual\"})\ndef dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n# Unit test for function dcfc_act_365_a\ndef test_dcfc_act_365_a():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:19:04.745062
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides day-count convention definitions and functionlity.\n\"\"\"\n\n__all__ = [\"DCC\", \"DCCRegistry\"]\n\nimport calendar\nimport datetime\nfrom decimal import Decimal\nfrom typing import Callable, Dict, Iterable, List, NamedTuple, Optional, Set, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom .commons.numbers import ONE, ZERO\nfrom .commons.zeitgeist import Date\nfrom .currencies import Currencies, Currency\nfrom .monetary import Money\n\n#: Defines a type alias for day count fraction calculation functions.\nDCFC = Callable[[Date, Date, Date, Optional[Decimal]], Decimal]\n\n\ndef _as_ccys(codes: Set[str]) -> Set[Currency]:\n    \"\"\"\n    Converts a set of currency codes to a set of currencies.\n    \"\"\"\n    return {Currencies[c] for c in codes}\n\n\ndef _get_date_range(start: Date, end: Date) -> Iterable[Date]:\n    \"\"\"\n    Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: A generator of dates.\n    \"\"\"\n    for i in range((end - start).days):\n        yield start + datetime.timedelta(days=i)\n\n\ndef _get_actual_day_count(start: Date, end: Date) -> int:\n    \"\"\"\n    Counts the actual number of days in the given period.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: The number of days in the given period.\n\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n    0\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n    1\n    \"\"\"\n    return (end - start).days\n\n\ndef _has_leap_day(start: Date, end: Date) -> bool:\n    \"\"\"\n    Indicates if the range has any leap day.\n    \"\"\"\n    ## Get all leap years:\n    years = {year for year in range(start.year, end.year + 1) if calendar.isleap(year)}\n\n    ## Check if any of the lap day falls in our range:\n    for year in years:\n        ## Construct the leap day:\n        leapday = datetime.date(year, 2, 29)\n\n        ## Is the leap date in the range?\n        if start <= leapday <= end:\n            ## Yes, the leap day is within the date range. Return True:\n            return True\n\n    ## No leap day in the range, return False:\n    return False\n\n\ndef _is_last_day_of_month(date: Date) -> bool:\n    \"\"\"\n    Indicates if the date is the last day of the month.\n    \"\"\"\n    return date.day == calendar.monthrange(date.year, date.month)[1]\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    ## Make sure that we have eom:\n    eom = eom or start.day\n\n    ## Get the starting month:\n    s_month = start.month\n\n    ## Get the period:\n    period = int(12 / frequency)\n\n    ## Get the current day, month and year:\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n\n    ## Get the payment schedule:\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period)])])\n\n    ## Filter out previous:\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n\n    ## Get the previous month and year:\n    p_year, p_month = (c_year, future[-1]) if future else (c_year - 1, schedule[-1])\n\n    ## Return the date:\n    if p_year < 1 or p_month < 1 or eom < 1:\n        return start\n\n    ## Construct and return the date safely:\n    return _construct_date(p_year, p_month, eom)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n# Unit test for method calculate_fraction of class DCC\ndef test_DCC_calculate_fraction():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:19:08.402079
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 German\", {\"30E/360 ISDA\"})\ndef dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    ## Get the new asof date, if required:\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_german\ndef test_dcfc_30_360_german():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:19:13.625558
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides day-count convention definitions and functionlity.\n\"\"\"\n\n__all__ = [\"DCC\", \"DCCRegistry\"]\n\nimport calendar\nimport datetime\nfrom decimal import Decimal\nfrom typing import Callable, Dict, Iterable, List, NamedTuple, Optional, Set, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom .commons.numbers import ONE, ZERO\nfrom .commons.zeitgeist import Date\nfrom .currencies import Currencies, Currency\nfrom .monetary import Money\n\n#: Defines a type alias for day count fraction calculation functions.\nDCFC = Callable[[Date, Date, Date, Optional[Decimal]], Decimal]\n\n\ndef _as_ccys(codes: Set[str]) -> Set[Currency]:\n    \"\"\"\n    Converts a set of currency codes to a set of currencies.\n    \"\"\"\n    return {Currencies[c] for c in codes}\n\n\ndef _get_date_range(start: Date, end: Date) -> Iterable[Date]:\n    \"\"\"\n    Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: A generator of dates.\n    \"\"\"\n    for i in range((end - start).days):\n        yield start + datetime.timedelta(days=i)\n\n\ndef _get_actual_day_count(start: Date, end: Date) -> int:\n    \"\"\"\n    Counts the actual number of days in the given period.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: The number of days in the given period.\n\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n    0\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n    1\n    \"\"\"\n    return (end - start).days\n\n\ndef _has_leap_day(start: Date, end: Date) -> bool:\n    \"\"\"\n    Indicates if the range has any leap day.\n    \"\"\"\n    ## Get all leap years:\n    years = {year for year in range(start.year, end.year + 1) if calendar.isleap(year)}\n\n    ## Check if any of the lap day falls in our range:\n    for year in years:\n        ## Construct the leap day:\n        leapday = datetime.date(year, 2, 29)\n\n        ## Is the leap date in the range?\n        if start <= leapday <= end:\n            ## Yes, the leap day is within the date range. Return True:\n            return True\n\n    ## No leap day in the range, return False:\n    return False\n\n\ndef _is_last_day_of_month(date: Date) -> bool:\n    \"\"\"\n    Indicates if the date is the last day of the month.\n    \"\"\"\n    return date.day == calendar.monthrange(date.year, date.month)[1]\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    ## Make sure that we have eom:\n    eom = eom or start.day\n\n    ## Get the starting month:\n    s_month = start.month\n\n    ## Get the period:\n    period = int(12 / frequency)\n\n    ## Get the current day, month and year:\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n\n    ## Get the payment schedule:\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period)])])\n\n    ## Filter out previous:\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n\n    ## Get the previous month and year:\n    p_year, p_month = (c_year, future[-1]) if future else (c_year - 1, schedule[-1])\n\n    ## Return the date:\n    if p_year < 1 or p_month < 1 or eom < 1:\n        return start\n\n    ## Construct and return the date safely:\n    return _construct_date(p_year, p_month, eom)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n# Unit test for method interest of class DCC\ndef test_DCC_interest():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:19:16.534184
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func\n\n    return register_and_return_dcfc\n\n\n@dcc(\"Act/Act\", {\"Actual/Actual\", \"Actual/Actual (ISDA)\"})\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    ## Get all years of interest by checking the leap year:\n    years = {year: calendar.isleap(year) for year in range(start.year, asof.year + 1)}\n\n    ## Define the buffer of days for the day count. The former is for non-leap years, the latter for leap years:\n    buffer: List[int] = [0, 0]\n\n    ## Iterate over the date range and count:\n    for date in _get_date_range(start, asof):\n        ## Check the year and modify buffer accordingly:\n        if years[date.year]:\n            ## Yep, it is a leap year:\n            buffer[1] += 1\n        else:\n            ## Nope, not a leap year:\n            buffer[0] += 1\n\n    ## Done, compute and return:\n    return Decimal(buffer[0]) / Decimal(365) + Decimal(buffer[1]) / Decimal(366)\n\n\n@dcc(\"Act/Act (ICMA)\", {\"Actual/Actual (ICMA)\", \"ISMA-99\", \"Act/Act (ISMA)\"})\ndef dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    ## Get the number of actual days:\n    p1 = Decimal(_get_actual_day_count(start, asof))\n\n    ## Get the number of days in the period:\n    p2 = Decimal(_get_actual_day_count(start, end))\n\n    ## Compute the ratio and return:\n    return p1 / p2 / Decimal(freq or ONE)\n\n\n@dcc(\n    \"Act/360\",\n    {\"Actual/360\", \"French\", \"360\"},\n    _as_ccys({\"AUD\", \"CAD\", \"CHF\", \"EUR\", \"USD\", \"DKK\", \"CZK\", \"HUF\", \"SEK\", \"IDR\", \"NOK\", \"JPY\", \"NZD\", \"THB\"}),\n)\ndef dcfc_act_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/360\" convention.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.17222222222222')\n    >>> round(dcfc_act_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17500000000000')\n    >>> round(dcfc_act_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.10000000000000')\n    >>> round(dcfc_act_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.34722222222222')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(360)\n\n\n@dcc(\"Act/365F\", {\"Actual/365 Fixed\", \"English\", \"365\"}, _as_ccys({\"GBP\", \"HKD\", \"INR\", \"PLN\", \"SGD\", \"ZAR\", \"MYR\"}))\ndef dcfc_act_365_f(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365F\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)\n\n\n@dcc(\"Act/365A\", {\"Actual/365 Actual\"})\ndef dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n# Unit test for function dcfc_act_365_l\ndef test_dcfc_act_365_l():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:19:19.492094
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_f(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_f(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17260273972603')\n    >>> round(dcfc_act_365_f(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08493150684932')\n    >>> round(dcfc_act_365_f(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(365)\n\n\n@dcc(\"Act/365A\", {\"Actual/365 Actual\"})\ndef dcfc_act_365_a(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365A\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_e_360\ndef test_dcfc_30_e_360():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:19:23.002370
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides day-count convention definitions and functionlity.\n\"\"\"\n\n__all__ = [\"DCC\", \"DCCRegistry\"]\n\nimport calendar\nimport datetime\nfrom decimal import Decimal\nfrom typing import Callable, Dict, Iterable, List, NamedTuple, Optional, Set, Union\n\nfrom dateutil.relativedelta import relativedelta\n\nfrom .commons.numbers import ONE, ZERO\nfrom .commons.zeitgeist import Date\nfrom .currencies import Currencies, Currency\nfrom .monetary import Money\n\n#: Defines a type alias for day count fraction calculation functions.\nDCFC = Callable[[Date, Date, Date, Optional[Decimal]], Decimal]\n\n\ndef _as_ccys(codes: Set[str]) -> Set[Currency]:\n    \"\"\"\n    Converts a set of currency codes to a set of currencies.\n    \"\"\"\n    return {Currencies[c] for c in codes}\n\n\ndef _get_date_range(start: Date, end: Date) -> Iterable[Date]:\n    \"\"\"\n    Returns a generator of dates falling into range within the given period (``end`` is exclusive).\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: A generator of dates.\n    \"\"\"\n    for i in range((end - start).days):\n        yield start + datetime.timedelta(days=i)\n\n\ndef _get_actual_day_count(start: Date, end: Date) -> int:\n    \"\"\"\n    Counts the actual number of days in the given period.\n\n    :param start: The start date of the period.\n    :param end: The end date of the period.\n    :return: The number of days in the given period.\n\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 1))\n    0\n    >>> _get_actual_day_count(datetime.date(2017, 1, 1), datetime.date(2017, 1, 2))\n    1\n    \"\"\"\n    return (end - start).days\n\n\ndef _has_leap_day(start: Date, end: Date) -> bool:\n    \"\"\"\n    Indicates if the range has any leap day.\n    \"\"\"\n    ## Get all leap years:\n    years = {year for year in range(start.year, end.year + 1) if calendar.isleap(year)}\n\n    ## Check if any of the lap day falls in our range:\n    for year in years:\n        ## Construct the leap day:\n        leapday = datetime.date(year, 2, 29)\n\n        ## Is the leap date in the range?\n        if start <= leapday <= end:\n            ## Yes, the leap day is within the date range. Return True:\n            return True\n\n    ## No leap day in the range, return False:\n    return False\n\n\ndef _is_last_day_of_month(date: Date) -> bool:\n    \"\"\"\n    Indicates if the date is the last day of the month.\n    \"\"\"\n    return date.day == calendar.monthrange(date.year, date.month)[1]\n\n\ndef _last_payment_date(start: Date, asof: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2015,  1,  1), datetime.date(2015, 12, 31), 1)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  8, 31), 2)\n    datetime.date(2015, 7, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  1,  1), datetime.date(2015,  4, 30), 2)\n    datetime.date(2015, 1, 1)\n\n    >>> _last_payment_date(datetime.date(2014,  6,  1), datetime.date(2015,  4, 30), 1)\n    datetime.date(2014, 6, 1)\n\n    >>> _last_payment_date(datetime.date(2008,  7,  7), datetime.date(2015, 10,  6), 4)\n    datetime.date(2015, 7, 7)\n\n    >>> _last_payment_date(datetime.date(2014, 12,  9), datetime.date(2015, 12,  4), 1)\n    datetime.date(2014, 12, 9)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2016,  1,  6), 2)\n    datetime.date(2015, 12, 15)\n\n    >>> _last_payment_date(datetime.date(2012, 12, 15), datetime.date(2015, 12, 31), 2)\n    datetime.date(2015, 12, 15)\n    \"\"\"\n    ## Make sure that we have eom:\n    eom = eom or start.day\n\n    ## Get the starting month:\n    s_month = start.month\n\n    ## Get the period:\n    period = int(12 / frequency)\n\n    ## Get the current day, month and year:\n    c_day, c_month, c_year = asof.day, asof.month, asof.year\n\n    ## Get the payment schedule:\n    schedule = sorted([i > 0 and i or 12 for i in sorted([(i + s_month) % 12 for i in range(0, 12, period)])])\n\n    ## Filter out previous:\n    future = [month for month in schedule if (month < c_month) or (month == c_month and eom <= c_day)]\n\n    ## Get the previous month and year:\n    p_year, p_month = (c_year, future[-1]) if future else (c_year - 1, schedule[-1])\n\n    ## Return the date:\n    if p_year < 1 or p_month < 1 or eom < 1:\n        return start\n\n    ## Construct and return the date safely:\n    return _construct_date(p_year, p_month, eom)\n\n\ndef _next_payment_date(start: Date, frequency: Union[int, Decimal], eom: Optional[int] = None) -> Date:\n    \"\"\"\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n# Unit test for method calculate_fraction of class DCC\ndef test_DCC_calculate_fraction():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:19:27.096898
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n\n\nclass DCCRegistryMachinery:\n    \"\"\"\n    Provides the day count registry model.\n\n    >>> principal = Money.of(Currencies[\"USD\"], Decimal(1000000), datetime.date.today())\n    >>> start = datetime.date(2007, 12, 28)\n    >>> end = datetime.date(2008, 2, 28)\n    >>> rate = Decimal(0.01)\n    >>> dcc = DCCRegistry.find(\"Act/Act\")\n    >>> round(dcc.calculate_fraction(start, end, end), 14)\n    Decimal('0.16942884946478')\n    >>> dcc.interest(principal, rate, start, end, end).qty\n    Decimal('1694.29')\n    >>> dcc.interest(principal, rate, end, start, start).qty\n    Decimal('0.00')\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        Initializes the registry.\n        \"\"\"\n        ## Define the main registry buffer:\n        self._buffer_main: Dict[str, DCC] = {}\n\n        ## Defines the registry buffer for alternative DCC names:\n        self._buffer_altn: Dict[str, DCC] = {}\n\n    def _is_registered(self, name: str) -> bool:\n        \"\"\"\n        Checks if the given name is ever registered before.\n        \"\"\"\n        return name in self._buffer_main or name in self._buffer_altn\n\n    def register(self, dcc: DCC) -> None:\n        \"\"\"\n        Attempts to register the given day count convention.\n        \"\"\"\n        ## Check if the main name is ever registered before:\n        if self._is_registered(dcc.name):\n            ## Yep, raise a TypeError:\n            raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n        ## Add to the main buffer:\n        self._buffer_main[dcc.name] = dcc\n\n        ## Check if there is any registry conflict:\n        for name in dcc.altnames:\n            ## Check if the name is ever registered:\n            if self._is_registered(name):\n                ## Yep, raise a TypeError:\n                raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n            ## Register to the alternative buffer:\n            self._buffer_altn[name] = dcc\n\n    def _find_strict(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n        \"\"\"\n        return self._buffer_main.get(name) or self._buffer_altn.get(name)\n\n    def find(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n\n        Note that all day count conventions are registered under stripped, uppercased names. Therefore,\n        the implementation will first attempt to find by given name as is. If it can not find it, it will\n        strip and uppercase the name and try to find it as such as a last resort.\n        \"\"\"\n        return self._find_strict(name) or self._find_strict(name.strip().upper())\n\n    @property\n    def registry(self) -> List[DCC]:\n        \"\"\"\n        Returns the main registry values.\n        \"\"\"\n        return list(self._buffer_main.values())\n\n    @property\n    def table(self) -> Dict[str, DCC]:\n        \"\"\"\n        Returns a lookup table for available day count conventions.\n        \"\"\"\n        return {**{k: v for k, v in self._buffer_main.items()}, **{k: v for k, v in self._buffer_altn.items()}}\n\n\n#: Defines the default DCC registry.\nDCCRegistry = DCCRegistryMachinery()\n\n\ndef dcc(name: str, altnames: Optional[Set[str]] = None, ccys: Optional[Set[Currency]] = None) -> Callable[[DCFC], DCFC]:\n    \"\"\"\n    Registers a day count fraction calculator under the given names and alternative names (if any).\n\n    :param name: The name of the day count convention.\n    :param altnames: A set of alternative names of the day count convention, if any.\n    :param ccys: A set of currencies which are known to use this convention by default, if any.\n    :return: Registered day count fraction calculation function.\n    \"\"\"\n\n    def register_and_return_dcfc(func: DCFC) -> DCFC:\n        \"\"\"\n        Registers the given day count fraction calculator and returns it.\n\n        :param func: Day count fraction calculation function to be registered.\n        :return: Registered day count fraction calculation function.\n        \"\"\"\n        ## Create the DCC instance:\n        dcc = DCC(name, altnames or set([]), ccys or set([]), func)\n\n        ## Attempt to register the DCC:\n        DCCRegistry.register(dcc)\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func\n\n    return register_and_return_dcfc\n\n\n@dcc(\"Act/Act\", {\"Actual/Actual\", \"Actual/Actual (ISDA)\"})\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    ## Get all years of interest by checking the leap year:\n    years = {year: calendar.isleap(year) for year in range(start.year, asof.year + 1)}\n\n    ## Define the buffer of days for the day count. The former is for non-leap years, the latter for leap years:\n    buffer: List[int] = [0, 0]\n\n    ## Iterate over the date range and count:\n    for date in _get_date_range(start, asof):\n        ## Check the year and modify buffer accordingly:\n        if years[date.year]:\n            ## Yep, it is a leap year:\n            buffer[1] += 1\n        else:\n            ## Nope, not a leap year:\n            buffer[0] += 1\n\n    ## Done, compute and return:\n    return Decimal(buffer[0]) / Decimal(365) + Decimal(buffer[1]) / Decimal(366)\n# Unit test for function dcfc_act_act\ndef test_dcfc_act_act():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:21:38.973382
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 German\", {\"30E/360 ISDA\"})\ndef dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    ## Get the new asof date, if required:\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_german\ndef test_dcfc_30_360_german():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:21:42.505404
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_e_plus_360\ndef test_dcfc_30_e_plus_360():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:21:45.634400
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_e_plus_360\ndef test_dcfc_30_e_plus_360():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:21:48.808742
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n\n\nclass DCCRegistryMachinery:\n    \"\"\"\n    Provides the day count registry model.\n\n    >>> principal = Money.of(Currencies[\"USD\"], Decimal(1000000), datetime.date.today())\n    >>> start = datetime.date(2007, 12, 28)\n    >>> end = datetime.date(2008, 2, 28)\n    >>> rate = Decimal(0.01)\n    >>> dcc = DCCRegistry.find(\"Act/Act\")\n    >>> round(dcc.calculate_fraction(start, end, end), 14)\n    Decimal('0.16942884946478')\n    >>> dcc.interest(principal, rate, start, end, end).qty\n    Decimal('1694.29')\n    >>> dcc.interest(principal, rate, end, start, start).qty\n    Decimal('0.00')\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        Initializes the registry.\n        \"\"\"\n        ## Define the main registry buffer:\n        self._buffer_main: Dict[str, DCC] = {}\n\n        ## Defines the registry buffer for alternative DCC names:\n        self._buffer_altn: Dict[str, DCC] = {}\n\n    def _is_registered(self, name: str) -> bool:\n        \"\"\"\n        Checks if the given name is ever registered before.\n        \"\"\"\n        return name in self._buffer_main or name in self._buffer_altn\n\n    def register(self, dcc: DCC) -> None:\n        \"\"\"\n        Attempts to register the given day count convention.\n        \"\"\"\n        ## Check if the main name is ever registered before:\n        if self._is_registered(dcc.name):\n            ## Yep, raise a TypeError:\n            raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n        ## Add to the main buffer:\n        self._buffer_main[dcc.name] = dcc\n\n        ## Check if there is any registry conflict:\n        for name in dcc.altnames:\n            ## Check if the name is ever registered:\n            if self._is_registered(name):\n                ## Yep, raise a TypeError:\n                raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n            ## Register to the alternative buffer:\n            self._buffer_altn[name] = dcc\n\n    def _find_strict(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n        \"\"\"\n        return self._buffer_main.get(name) or self._buffer_altn.get(name)\n\n    def find(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n\n        Note that all day count conventions are registered under stripped, uppercased names. Therefore,\n        the implementation will first attempt to find by given name as is. If it can not find it, it will\n        strip and uppercase the name and try to find it as such as a last resort.\n        \"\"\"\n        return self._find_strict(name) or self._find_strict(name.strip().upper())\n\n    @property\n    def registry(self) -> List[DCC]:\n        \"\"\"\n        Returns the main registry values.\n        \"\"\"\n        return list(self._buffer_main.values())\n\n    @property\n    def table(self) -> Dict[str, DCC]:\n        \"\"\"\n        Returns a lookup table for available day count conventions.\n        \"\"\"\n        return {**{k: v for k, v in self._buffer_main.items()}, **{k: v for k, v in self._buffer_altn.items()}}\n\n\n#: Defines the default DCC registry.\nDCCRegistry = DCCRegistryMachinery()\n\n\ndef dcc(name: str, altnames: Optional[Set[str]] = None, ccys: Optional[Set[Currency]] = None) -> Callable[[DCFC], DCFC]:\n    \"\"\"\n    Registers a day count fraction calculator under the given names and alternative names (if any).\n\n    :param name: The name of the day count convention.\n    :param altnames: A set of alternative names of the day count convention, if any.\n    :param ccys: A set of currencies which are known to use this convention by default, if any.\n    :return: Registered day count fraction calculation function.\n    \"\"\"\n\n    def register_and_return_dcfc(func: DCFC) -> DCFC:\n        \"\"\"\n        Registers the given day count fraction calculator and returns it.\n\n        :param func: Day count fraction calculation function to be registered.\n        :return: Registered day count fraction calculation function.\n        \"\"\"\n        ## Create the DCC instance:\n        dcc = DCC(name, altnames or set([]), ccys or set([]), func)\n\n        ## Attempt to register the DCC:\n        DCCRegistry.register(dcc)\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func\n\n    return register_and_return_dcfc\n\n\n@dcc(\"Act/Act\", {\"Actual/Actual\", \"Actual/Actual (ISDA)\"})\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    ## Get all years of interest by checking the leap year:\n    years = {year: calendar.isleap(year) for year in range(start.year, asof.year + 1)}\n\n    ## Define the buffer of days for the day count. The former is for non-leap years, the latter for leap years:\n    buffer: List[int] = [0, 0]\n\n    ## Iterate over the date range and count:\n    for date in _get_date_range(start, asof):\n        ## Check the year and modify buffer accordingly:\n        if years[date.year]:\n            ## Yep, it is a leap year:\n            buffer[1] += 1\n        else:\n            ## Nope, not a leap year:\n            buffer[0] += 1\n\n    ## Done, compute and return:\n    return Decimal(buffer[0]) / Decimal(365) + Decimal(buffer[1]) / Decimal(366)\n\n\n@dcc(\"Act/Act (ICMA)\", {\"Actual/Actual (ICMA)\", \"ISMA-99\", \"Act/Act (ISMA)\"})\ndef dcfc_act_act_icma(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act (ICMA)\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof, ex1_end = datetime.date(2019, 3, 2), datetime.date(2019, 9, 10), datetime.date(2020, 3, 2)\n    >>> round(dcfc_act_act_icma(start=ex1_start, asof=ex1_asof, end=ex1_end), 10)\n    Decimal('0.5245901639')\n    \"\"\"\n    ## Get the number of actual days:\n    p1 = Decimal(_get_actual_day_count(start, asof))\n\n    ## Get the number of days in the period:\n    p2 = Decimal(_get_actual_day_count(start, end))\n\n    ## Compute the ratio and return:\n    return p1 / p2 / Decimal(freq or ONE)\n# Unit test for function dcfc_act_act_icma\ndef test_dcfc_act_act_icma():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:21:51.841597
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_e_plus_360\ndef test_dcfc_30_e_plus_360():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:21:56.004389
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    >>> round(dcfc_act_365_a(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_act_365_a(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_a(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_a(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32513661202186')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if _has_leap_day(start, asof) else 365)\n\n\n@dcc(\"Act/365L\", {\"Actual/365 Leap Year\"})\ndef dcfc_act_365_l(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"Act/365L\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_365_l(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16939890710383')\n    >>> round(dcfc_act_365_l(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17213114754098')\n    >>> round(dcfc_act_365_l(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08196721311475')\n    >>> round(dcfc_act_365_l(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_e_plus_360\ndef test_dcfc_30_e_plus_360():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:21:59.270695
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    Returns the last coupon payment date.\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, None)\n    datetime.date(2015, 1, 1)\n\n    >>> _next_payment_date(datetime.date(2014,  1,  1), 1, 15)\n    datetime.date(2015, 1, 15)\n    \"\"\"\n    ## Get the number of months to move forward:\n    months = int(12 / frequency)\n\n    ## Find the next date:\n    nextdate = start + relativedelta(months=months)\n\n    ## Do we have any end of month?\n    if eom:\n        try:\n            nextdate = nextdate.replace(day=eom)\n        except ValueError:\n            pass\n\n    ## Done, return:\n    return nextdate\n\n\ndef _construct_date(year: int, month: int, day: int) -> Date:\n    \"\"\"\n    Constructs and returns date safely.\n    \"\"\"\n    if year <= 0 or month <= 0 or day <= 0:\n        raise ValueError(\"year, month and day must be greater than 0.\")\n    try:\n        return datetime.date(year, month, day)\n    except ValueError as exc:\n        if str(exc) == \"day is out of range for month\":\n            return _construct_date(year, month, day - 1)\n        else:\n            raise exc\n\n\nclass DCC(NamedTuple):\n    \"\"\"\n    Defines a day count convention model.\n    \"\"\"\n\n    #: Defines the name of the day count convention.\n    name: str\n\n    #: Defines a set of alternative names of the day count convention.\n    altnames: Set[str]\n\n    #: Defines a set of currencies which are known to use this convention by default.\n    currencies: Set[Currency]\n\n    #: Defines the day count fraction calculation method function.\n    calculate_fraction_method: DCFC\n\n    def calculate_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates the day count fraction based on the underlying methodology after performing some general checks.\n        \"\"\"\n        ## Checks if dates are provided properly:\n        if not start <= asof <= end:\n            ## Nope, return 0:\n            return ZERO\n\n        ## Cool, we can proceed with calculation based on the methodology:\n        return self[3](start, asof, end, freq)\n\n    def calculate_daily_fraction(self, start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n        \"\"\"\n        Calculates daily fraction.\n        \"\"\"\n        ## Get t-1 for asof:\n        asof_minus_1 = asof - datetime.timedelta(days=1)\n\n        ## Get the yesterday's factor:\n        if asof_minus_1 < start:\n            yfact = ZERO\n        else:\n            yfact = self.calculate_fraction_method(start, asof_minus_1, end, freq)\n\n        ## Get today's factor:\n        tfact = self.calculate_fraction_method(start, asof, end, freq)\n\n        ## Get the factor and return:\n        return tfact - yfact\n\n    def interest(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Optional[Date] = None,\n        freq: Optional[Decimal] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest.\n        \"\"\"\n        return principal * rate * self.calculate_fraction(start, asof, end or asof, freq)\n\n    def coupon(\n        self,\n        principal: Money,\n        rate: Decimal,\n        start: Date,\n        asof: Date,\n        end: Date,\n        freq: Union[int, Decimal],\n        eom: Optional[int] = None,\n    ) -> Money:\n        \"\"\"\n        Calculates the accrued interest for the coupon payment.\n\n        This method is primarily used for bond coupon accruals which assumes the start date to be the first of regular\n        payment schedules.\n        \"\"\"\n        ## Find the previous and next payment dates:\n        prevdate = _last_payment_date(start, asof, freq, eom)\n        nextdate = _next_payment_date(prevdate, freq, eom)\n\n        ## Calculate the interest and return:\n        return self.interest(principal, rate, prevdate, asof, nextdate, Decimal(freq))\n\n\nclass DCCRegistryMachinery:\n    \"\"\"\n    Provides the day count registry model.\n\n    >>> principal = Money.of(Currencies[\"USD\"], Decimal(1000000), datetime.date.today())\n    >>> start = datetime.date(2007, 12, 28)\n    >>> end = datetime.date(2008, 2, 28)\n    >>> rate = Decimal(0.01)\n    >>> dcc = DCCRegistry.find(\"Act/Act\")\n    >>> round(dcc.calculate_fraction(start, end, end), 14)\n    Decimal('0.16942884946478')\n    >>> dcc.interest(principal, rate, start, end, end).qty\n    Decimal('1694.29')\n    >>> dcc.interest(principal, rate, end, start, start).qty\n    Decimal('0.00')\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        Initializes the registry.\n        \"\"\"\n        ## Define the main registry buffer:\n        self._buffer_main: Dict[str, DCC] = {}\n\n        ## Defines the registry buffer for alternative DCC names:\n        self._buffer_altn: Dict[str, DCC] = {}\n\n    def _is_registered(self, name: str) -> bool:\n        \"\"\"\n        Checks if the given name is ever registered before.\n        \"\"\"\n        return name in self._buffer_main or name in self._buffer_altn\n\n    def register(self, dcc: DCC) -> None:\n        \"\"\"\n        Attempts to register the given day count convention.\n        \"\"\"\n        ## Check if the main name is ever registered before:\n        if self._is_registered(dcc.name):\n            ## Yep, raise a TypeError:\n            raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n        ## Add to the main buffer:\n        self._buffer_main[dcc.name] = dcc\n\n        ## Check if there is any registry conflict:\n        for name in dcc.altnames:\n            ## Check if the name is ever registered:\n            if self._is_registered(name):\n                ## Yep, raise a TypeError:\n                raise TypeError(f\"Day count convention '{dcc.name}' is already registered\")\n\n            ## Register to the alternative buffer:\n            self._buffer_altn[name] = dcc\n\n    def _find_strict(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n        \"\"\"\n        return self._buffer_main.get(name) or self._buffer_altn.get(name)\n\n    def find(self, name: str) -> Optional[DCC]:\n        \"\"\"\n        Attempts to find the day count convention by the given name.\n\n        Note that all day count conventions are registered under stripped, uppercased names. Therefore,\n        the implementation will first attempt to find by given name as is. If it can not find it, it will\n        strip and uppercase the name and try to find it as such as a last resort.\n        \"\"\"\n        return self._find_strict(name) or self._find_strict(name.strip().upper())\n\n    @property\n    def registry(self) -> List[DCC]:\n        \"\"\"\n        Returns the main registry values.\n        \"\"\"\n        return list(self._buffer_main.values())\n\n    @property\n    def table(self) -> Dict[str, DCC]:\n        \"\"\"\n        Returns a lookup table for available day count conventions.\n        \"\"\"\n        return {**{k: v for k, v in self._buffer_main.items()}, **{k: v for k, v in self._buffer_altn.items()}}\n\n\n#: Defines the default DCC registry.\nDCCRegistry = DCCRegistryMachinery()\n\n\ndef dcc(name: str, altnames: Optional[Set[str]] = None, ccys: Optional[Set[Currency]] = None) -> Callable[[DCFC], DCFC]:\n    \"\"\"\n    Registers a day count fraction calculator under the given names and alternative names (if any).\n\n    :param name: The name of the day count convention.\n    :param altnames: A set of alternative names of the day count convention, if any.\n    :param ccys: A set of currencies which are known to use this convention by default, if any.\n    :return: Registered day count fraction calculation function.\n    \"\"\"\n\n    def register_and_return_dcfc(func: DCFC) -> DCFC:\n        \"\"\"\n        Registers the given day count fraction calculator and returns it.\n\n        :param func: Day count fraction calculation function to be registered.\n        :return: Registered day count fraction calculation function.\n        \"\"\"\n        ## Create the DCC instance:\n        dcc = DCC(name, altnames or set([]), ccys or set([]), func)\n\n        ## Attempt to register the DCC:\n        DCCRegistry.register(dcc)\n\n        ## Attach the dcc instance to the day count fraction calculation function (for whatever it is worth):\n        setattr(func, \"__dcc\", dcc)\n\n        ## Done, return the function (if above statment did not raise any exceptions):\n        return func\n\n    return register_and_return_dcfc\n\n\n@dcc(\"Act/Act\", {\"Actual/Actual\", \"Actual/Actual (ISDA)\"})\ndef dcfc_act_act(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for \"Act/Act\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :param freq: The frequency of payments in a year.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_act_act(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16942884946478')\n    >>> round(dcfc_act_act(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.17216108990194')\n    >>> round(dcfc_act_act(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08243131970956')\n    >>> round(dcfc_act_act(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32625945055768')\n    \"\"\"\n    ## Get all years of interest by checking the leap year:\n    years = {year: calendar.isleap(year) for year in range(start.year, asof.year + 1)}\n\n    ## Define the buffer of days for the day count. The former is for non-leap years, the latter for leap years:\n    buffer: List[int] = [0, 0]\n\n    ## Iterate over the date range and count:\n    for date in _get_date_range(start, asof):\n        ## Check the year and modify buffer accordingly:\n        if years[date.year]:\n            ## Yep, it is a leap year:\n            buffer[1] += 1\n        else:\n            ## Nope, not a leap year:\n            buffer[0] += 1\n\n    ## Done, compute and return:\n    return Decimal(buffer[0]) / Decimal(365) + Decimal(buffer[1]) / Decimal(366)\n# Unit test for function dcfc_act_act\ndef test_dcfc_act_act():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:22:02.315888
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 German\", {\"30E/360 ISDA\"})\ndef dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    ## Get the new asof date, if required:\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_german\ndef test_dcfc_30_360_german():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:22:05.367246
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    Decimal('1.32876712328767')\n    \"\"\"\n    return _get_actual_day_count(start, asof) / Decimal(366 if calendar.isleap(asof.year) else 365)\n\n\n@dcc(\"NL/365\", {\"Actual/365 No Leap Year\", \"NL365\"})\ndef dcfc_nl_365(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"NL/365\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_nl_365(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16986301369863')\n    >>> round(dcfc_nl_365(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08219178082192')\n    >>> round(dcfc_nl_365(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.32602739726027')\n    \"\"\"\n    return (_get_actual_day_count(start, asof) - (1 if _has_leap_day(start, asof) else 0)) / Decimal(365)\n\n\n@dcc(\"30/360 ISDA\", {\"30/360 US Municipal\", \"Bond Basis\"})\ndef dcfc_30_360_isda(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 ISDA\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 German\", {\"30E/360 ISDA\"})\ndef dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    ## Get the new asof date, if required:\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_german\ndef test_dcfc_30_360_german():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 03:22:08.601271
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_isda(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_isda(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_isda(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_isda(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if start.day == 30 and asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E/360\", {\"30/360 ISMA\", \"30/360 European\", \"30S/360 Special German\", \"Eurobond Basis\"})\ndef dcfc_30_e_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = datetime.date(asof.year, asof.month, 30)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30E+/360\")\ndef dcfc_30_e_plus_360(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30E+/360\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_e_plus_360(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_e_plus_360(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_e_plus_360(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_e_plus_360(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31:\n        start = datetime.date(start.year, start.month, 30)\n\n    ## Get the new asof date, if required:\n    if asof.day == 31:\n        asof = asof + datetime.timedelta(days=1)\n\n    ## Compute number of days:\n    nod = (asof.day - start.day) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 German\", {\"30E/360 ISDA\"})\ndef dcfc_30_360_german(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_german(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_german(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_german(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_german(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33055555555556')\n    \"\"\"\n    ## Get the new start date, if required:\n    if start.day == 31 or (start.month == 2 and _is_last_day_of_month(start)):\n        d1 = 30\n    else:\n        d1 = start.day\n\n    ## Get the new asof date, if required:\n    if asof.day == 31 or (asof.month == 2 and _is_last_day_of_month(asof) and end != asof):\n        d2 = 30\n    else:\n        d2 = asof.day\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, compute and return the day count fraction:\n    return nod / Decimal(360)\n\n\n@dcc(\"30/360 US\", {\"30U/360\", \"30US/360\"})\ndef dcfc_30_360_us(start: Date, asof: Date, end: Date, freq: Optional[Decimal] = None) -> Decimal:\n    \"\"\"\n    Computes the day count fraction for the \"30/360 US\" convention.\n\n    :param start: The start date of the period.\n    :param asof: The date which the day count fraction to be calculated as of.\n    :param end: The end date of the period (a.k.a. termination date).\n    :return: Day count fraction.\n\n    >>> ex1_start, ex1_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 28)\n    >>> ex2_start, ex2_asof = datetime.date(2007, 12, 28), datetime.date(2008, 2, 29)\n    >>> ex3_start, ex3_asof = datetime.date(2007, 10, 31), datetime.date(2008, 11, 30)\n    >>> ex4_start, ex4_asof = datetime.date(2008, 2, 1), datetime.date(2009, 5, 31)\n    >>> round(dcfc_30_360_us(start=ex1_start, asof=ex1_asof, end=ex1_asof), 14)\n    Decimal('0.16666666666667')\n    >>> round(dcfc_30_360_us(start=ex2_start, asof=ex2_asof, end=ex2_asof), 14)\n    Decimal('0.16944444444444')\n    >>> round(dcfc_30_360_us(start=ex3_start, asof=ex3_asof, end=ex3_asof), 14)\n    Decimal('1.08333333333333')\n    >>> round(dcfc_30_360_us(start=ex4_start, asof=ex4_asof, end=ex4_asof), 14)\n    Decimal('1.33333333333333')\n    \"\"\"\n    ## Get D1 and D2:\n    d1 = start.day\n    d2 = asof.day\n\n    ## Need to change D1?\n    if _is_last_day_of_month(start):\n        ## Yep, change it:\n        d1 = 30\n\n        ## Shall we change the d2, too?\n        if _is_last_day_of_month(asof):\n            d2 = 30\n\n    ## Revisit d2:\n    if d2 == 31 and (d1 == 30 or d1 == 31):\n        d2 = 30\n\n    ## Revisit d1:\n    if d1 == 31:\n        d1 = 30\n\n    ## Compute number of days:\n    nod = (d2 - d1) + 30 * (asof.month - start.month) + 360 * (asof.year - start.year)\n\n    ## Done, return:\n    return nod / Decimal(360)\n# Unit test for function dcfc_30_360_us\ndef test_dcfc_30_360_us():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}