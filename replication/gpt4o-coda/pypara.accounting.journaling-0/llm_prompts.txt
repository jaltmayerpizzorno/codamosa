

---- 2024-06-03 02:44:04.429632
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:07.584245
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:11.602634
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:16.039967
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:18.449854
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:20.817950
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:24.672559
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:27.964181
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:31.214566
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:33.566636
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:46.006893
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:49.345180
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:52.501156
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:44:55.842906
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:00.565537
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:03.652607
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:08.258916
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:12.268426
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:15.602130
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:19.086269
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:40.717288
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:44.259332
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:48.118174
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:51.006058
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:53.899696
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:45:56.470936
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:46:01.477163
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:46:03.991668
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:46:07.175136
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:46:10.116547
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:46:42.992117
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:46:46.385617
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:46:50.069800
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:46:52.668358
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:46:56.992449
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:47:00.243630
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:47:03.330140
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:47:07.428533
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:47:11.813111
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:47:17.016624
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:48:41.074073
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:48:43.902142
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:48:46.686809
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:48:49.144149
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:48:51.872068
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:48:57.497560
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:49:00.583017
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:49:03.450416
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:49:07.830281
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:49:10.847496
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:51:57.684899
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:52:02.003791
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:52:06.011962
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:52:08.464794
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:52:11.589956
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:52:14.099349
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:52:19.337788
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:52:23.171346
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method __call__ of class ReadJournalEntries\ndef test_ReadJournalEntries___call__():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:52:27.902061
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method validate of class JournalEntry\ndef test_JournalEntry_validate():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}

---- 2024-06-03 02:52:30.932503
{"model": "gpt-4o-2024-05-13", "messages": [{"role": "user", "content": "Complete the following unit test function. Only write the completion; do NOT rewrite the function. Do NOT include any comments or description.\n\"\"\"\nThis module provides data definitions and functionality related to journal entries and postings.\n\"\"\"\n\n__all__ = [\n    \"Direction\",\n    \"JournalEntry\",\n    \"Posting\",\n    \"ReadJournalEntries\",\n]\n\nimport datetime\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Dict, Generic, Iterable, List, Protocol, Set, TypeVar\n\nfrom ..commons.numbers import Amount, Quantity, isum\nfrom ..commons.others import Guid, makeguid\nfrom ..commons.zeitgeist import DateRange\nfrom .accounts import Account, AccountType\n\n#: Defines a type variable.\n_T = TypeVar(\"_T\")\n\n\nclass Direction(Enum):\n    \"\"\"\n    Provides an enumeration for indicating increment and decrement events.\n    \"\"\"\n\n    #: Declares the value type.\n    value: int\n\n    #: Indicates increment events.\n    INC = +1\n\n    #: Indicates decrement events.\n    DEC = -1\n\n    @classmethod\n    def of(cls, quantity: Quantity) -> \"Direction\":\n        \"\"\"\n        Returns the corresponding direction as per the sign of the quantity.\n\n        :param quantity: Quantity to find the direction of.\n        :return: Direction for the quantity.\n        :raises AssertionError: If quantity is zero which implies a programming error.\n        \"\"\"\n        assert not quantity.is_zero(), \"Encountered a `0` quantity. This implies a programming error.\"\n        return Direction.INC if quantity > 0 else Direction.DEC\n\n\n#: Provides the mapping for DEBIT/CREDIT convention as per increment/decrement and account type.\n_debit_mapping: Dict[Direction, Set[AccountType]] = {\n    Direction.INC: {AccountType.ASSETS, AccountType.EQUITIES, AccountType.LIABILITIES},\n    Direction.DEC: {AccountType.REVENUES, AccountType.EXPENSES},\n}\n\n\n@dataclass(frozen=True)\nclass Posting(Generic[_T]):\n    \"\"\"\n    Provides a posting value object model.\n    \"\"\"\n\n    #: Journal entry the posting belongs to.\n    journal: \"JournalEntry[_T]\"\n\n    #: Date of posting.\n    date: datetime.date\n\n    #: Account of the posting.\n    account: Account\n\n    #: Direction of the posting.\n    direction: Direction\n\n    #: Posted amount (in absolute value).\n    amount: Amount\n\n    @property\n    def is_debit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a debit.\n        \"\"\"\n        return self.account.type in _debit_mapping[self.direction]\n\n    @property\n    def is_credit(self) -> bool:\n        \"\"\"\n        Indicates if this posting is a credit.\n        \"\"\"\n        return not self.is_debit\n\n\n@dataclass(frozen=True)\nclass JournalEntry(Generic[_T]):\n    \"\"\"\n    Provides a journal entry model.\n    \"\"\"\n\n    #: Date of the entry.\n    date: datetime.date\n\n    #: Description of the entry.\n    description: str\n\n    #: Business object as the source of the journal entry.\n    source: _T\n\n    #: Postings of the journal entry.\n    postings: List[Posting[_T]] = field(default_factory=list, init=False)\n\n    #: Globally unique, ephemeral identifier.\n    guid: Guid = field(default_factory=makeguid, init=False)\n\n    @property\n    def increments(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Incerement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.INC)\n\n    @property\n    def decrements(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Decrement event postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.direction == Direction.DEC)\n\n    @property\n    def debits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Debit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_debit)\n\n    @property\n    def credits(self) -> Iterable[Posting[_T]]:\n        \"\"\"\n        Credit postings of the journal entry.\n        \"\"\"\n        return (p for p in self.postings if p.is_credit)\n\n    def post(self, date: datetime.date, account: Account, quantity: Quantity) -> \"JournalEntry[_T]\":\n        \"\"\"\n        Posts an increment/decrement event (depending on the sign of ``quantity``) to the given account.\n\n        If the quantity is ``0``, nothing is posted.\n\n        :param date: Date of posting.\n        :param account: Account to post the amount to.\n        :param quantity: Signed-value to post to the account.\n        :return: This journal entry (to be chained conveniently).\n        \"\"\"\n        if not quantity.is_zero():\n            self.postings.append(Posting(self, date, account, Direction.of(quantity), Amount(abs(quantity))))\n        return self\n\n    def validate(self) -> None:\n        \"\"\"\n        Performs validations on the instance.\n\n        :raises AssertionError: If the journal entry is inconsistent.\n        \"\"\"\n        ## Get total debit and credit amounts:\n        total_debit = isum(i.amount for i in self.debits)\n        total_credit = isum(i.amount for i in self.credits)\n\n        ## Check:\n        assert total_debit == total_credit, f\"Total Debits and Credits are not equal: {total_debit} != {total_credit}\"\n\n\nclass ReadJournalEntries(Protocol[_T]):\n    \"\"\"\n    Type of functions which read journal entries from a source.\n    \"\"\"\n\n    def __call__(self, period: DateRange) -> Iterable[JournalEntry[_T]]:\n        pass\n\n# Unit test for method post of class JournalEntry\ndef test_JournalEntry_post():"}], "max_tokens": 200, "temperature": 0.0, "stop": ["\n# Unit test for", "\ndef ", "\nclass "]}